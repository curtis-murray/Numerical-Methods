[
  {
    "objectID": "Lesson_1.html#variables",
    "href": "Lesson_1.html#variables",
    "title": "3  An Introduction to R Programming",
    "section": "3.1 Variables",
    "text": "3.1 Variables\nA variable in R is an object that takes a value. This is similar to a variable in mathematics, for example, \\(x = 3\\). However, in R, a variable can be more things than just a number! A variable can take a numeric, a string, a logical (like TRUE or FALSE), and even a function!\nTo assign a value to a variable, we use the assignment operator <-, together with the variable name and the value we want to assign to the variable.\nFor example, for the assignment of the string \"Ollie\" to the variable cat – this is just the variable name – we write the following:\n\n\nCode\ncat <- \"Ollie\"\n\n\nThe variable cat stores the string \"Ollie\" in the computer’s memory. When we call the variable, it will return its value.\n\n\nCode\ncat\n\n\n[1] \"Ollie\"\n\n\nNotice that the string is wrapped in quotation marks, and the variable is not. This is important to remember as if you forget to wrap a string in quotes, R will think it’s a variable, and if you wrap a variable in quotes, R will think it’s a string:\n\n\nCode\n\"cat\"\n\n\n[1] \"cat\"\n\n\n\n\nCode\nOllie\n\n\nError in eval(expr, envir, enclos): object 'Ollie' not found"
  },
  {
    "objectID": "Lesson_1.html#variable-types",
    "href": "Lesson_1.html#variable-types",
    "title": "3  An Introduction to R Programming",
    "section": "3.2 Variable Types",
    "text": "3.2 Variable Types\n\n3.2.1 Strings\nWe saw strings above!\n\n\n3.2.2 Numeric Type and Operators\nWe have seen that a variable can be a string, i.e., a sequence of characters. Now let’s see a numeric variable.\n\n\nCode\nage <- 85\nage\n\n\n[1] 85\n\n\nWe can perform standard mathematical operations on numeric variables.\n\n\nCode\n# Powers\nage^2\n\n\n[1] 7225\n\n\nCode\n# Multiplication\nage*2\n\n\n[1] 170\n\n\nCode\n# Subtraction\nage-10\n\n\n[1] 75\n\n\nCode\n# Addition\nage+5\n\n\n[1] 90\n\n\nCode\n# Division\nage/5\n\n\n[1] 17\n\n\nWe can perform a complex calculation with logarithms and \\(\\pi\\), written in R as pi.\n\n\nCode\n(log(age) + 100*pi)/1000\n\n\n[1] 0.3186019\n\n\nAnother operator is the remainder after division operator %%\nFor example, the remainder of division of \\(100\\) by \\(3\\) is \\(1\\), since \\(100 \\text{ mod }3 \\equiv 1\\)\n\n\nCode\nage %% 3\n\n\n[1] 1\n\n\nWe can also store the result of one calculation in a variable!\n\n\nCode\nage_last_year <- age-1\nage_last_year\n\n\n[1] 84\n\n\nThis is an incredibly useful feature of programming languages, as it allows you to build up a series of operations to perform powerful computations.\n\n\n3.2.3 Logical Type and Operators\nLogical variables, like TRUE and FALSE, as they suggest, tell us if something is true or false.\nFor example, we can check for equality with the equal to operator ==.\n\n\nCode\n2 == 2\n\n\n[1] TRUE\n\n\nCode\ncat == \"Ollie\"\n\n\n[1] TRUE\n\n\nCode\ncat == 3\n\n\n[1] FALSE\n\n\nThe result of the statement with an equality operator is a logical type that tells us whether or not the statement was TRUE or FALSE.\nSimilary, there is the not equal to operator !=, and inequality operators <, >, <=, and >=.\nThere are special logical operators that take logicals and return logicals. An example is the AND operator &.\nThe AND operator takes two inputs, for example, A and B. A & B will be TRUE if A AND B are TRUE, and FALSE otherwise, hence the name.\nBelow is a table of common operators.\n\n\n\n\n\n\n\n\n\nOperator\nDescription\nExample\nResult\n\n\n\n\n&\nLogical AND\nA & B\nTRUE if both A and B are TRUE, FALSE otherwise\n\n\n|\nLogical OR\nA | B\nTRUE if either A or B is TRUE, FALSE otherwise\n\n\n!\nLogical NOT\n!A\nTRUE if A is FALSE, FALSE if A is TRUE\n\n\n&&\nShort-circuit AND\nA && B\nTRUE if both A and B are TRUE, FALSE otherwise. B is not evaluated if A is FALSE.\n\n\n||\nShort-circuit OR\nA || B\nTRUE if either A or B is TRUE, FALSE otherwise. B is not evaluated if A is TRUE."
  },
  {
    "objectID": "Lesson_1.html#vectors",
    "href": "Lesson_1.html#vectors",
    "title": "3  An Introduction to R Programming",
    "section": "3.3 Vectors",
    "text": "3.3 Vectors\nIn R, a vector is a collection of elements of the same data type. A vector can be created using the c() function. A good way to remember this is you take a collection. Here are some examples:\nCreating a vector of integers from 1 to 10:\n\n\nCode\none_to_ten <- 1:10\none_to_ten\n\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nCreating a vector of strings:\n\n\nCode\nfruits <- c(\"apple\", \"banana\", \"orange\")\nfruits\n\n\n[1] \"apple\"  \"banana\" \"orange\"\n\n\nCreating a vector using the seq() function:\n\n\nCode\nodd_numbers_below_ten <- seq(from = 1, to = 10, by = 2)\nodd_numbers_below_ten\n\n\n[1] 1 3 5 7 9\n\n\nVectors are an important data structure in R and are used extensively in data analysis and statistical modeling. They can be operated on using various functions and operators, including arithmetic operators, logical operators, and mathematical functions.\nFor example, we can do element-wise mathematical operations\n\n\nCode\none_to_ten + 1\n\n\n [1]  2  3  4  5  6  7  8  9 10 11\n\n\nCode\none_to_ten*2\n\n\n [1]  2  4  6  8 10 12 14 16 18 20\n\n\nCode\none_to_ten/(one_to_ten^2)\n\n\n [1] 1.0000000 0.5000000 0.3333333 0.2500000 0.2000000 0.1666667 0.1428571\n [8] 0.1250000 0.1111111 0.1000000\n\n\nCode\none_to_ten%%2\n\n\n [1] 1 0 1 0 1 0 1 0 1 0\n\n\nWe can access elements of a vector using square bracket notation [] and specifying the index of the element we want to retrieve.\n\n\nCode\nfruits[1]\n\n\n[1] \"apple\"\n\n\nWe can pass in a vector of indices as well! In the below example, we say we want the first two elements of the fruits vector.\n\n\nCode\nfruits[1:2]\n\n\n[1] \"apple\"  \"banana\"\n\n\nCode\nfruits[c(1,2)]\n\n\n[1] \"apple\"  \"banana\"\n\n\nWhat happens if we pass in the indices in a different order, e.g., instead of fruits[c(1,2)], we put in fruits[c(2,1)]? What do you think will happen? Try it yourself. Does the result make sense?\nWe can add a new element to a vector:\n\n\nCode\nfruits[4] <- \"mango\"\nfruits\n\n\n[1] \"apple\"  \"banana\" \"orange\" \"mango\""
  },
  {
    "objectID": "Lesson_1.html#if-statements",
    "href": "Lesson_1.html#if-statements",
    "title": "3  An Introduction to R Programming",
    "section": "3.4 If Statements",
    "text": "3.4 If Statements\nIn R, if statements give a way to execute (run) code only if a logical condition is met. This is a powerful way to model a process that has multiple branches depending on its input. For example, in Spring, we may buy strawberries.\n\n\nCode\nseason <- \"spring\"\n\nif(season == \"spring\"){\n  print(\"I'm going to buy strawberries\")\n}\n\n\n[1] \"I'm going to buy strawberries\"\n\n\nWhat about if it isn’t Spring?\n\n\nCode\nseason <- \"autumn\"\n\nif(season == \"spring\"){\n  print(\"I'm going to buy strawberries :D\")\n}\n\n\nNothing happens!\nWe may want to specific the behavior for when the condition in the if statement is not met. To do this, we can add an else statement.\n\n\nCode\nseason <- \"autumn\"\n\nif(season == \"spring\"){\n  print(\"I'm going to buy strawberries :D\")\n}else{\n  print(\"I'm not going to buy strawberries :'(\")\n}\n\n\n[1] \"I'm not going to buy strawberries :'(\"\n\n\nWe will see more examples of if statements in the following section."
  },
  {
    "objectID": "Lesson_1.html#for-loops",
    "href": "Lesson_1.html#for-loops",
    "title": "3  An Introduction to R Programming",
    "section": "3.5 For Loops",
    "text": "3.5 For Loops\nIntroduction In R programming, loops are a powerful tool that allow you to repeat a sequence of code multiple times. A for loop is a type of loop that is used to execute a block of code repeatedly based on a given number of iterations. for loops are particularly useful when you want to perform the same action on each element in a vector or list.\nIn the following example, for each fruit in ourfruits` vector, we print the fruit.\n\n\nCode\nfor(fruit in fruits){\n  print(fruit)\n}\n\n\n[1] \"apple\"\n[1] \"banana\"\n[1] \"orange\"\n[1] \"mango\"\n\n\nNotice that the syntax (the specific way we specify the code) reads very similar to the English used to describe its behavior. When we run the for loop, the code inside the curly braces {} is run for each element (fruit) in the vector we iterate over (fruits). Initially, the loop iterator variable fruit takes the value of the first element of the fruits vector. Once the code inside the braces has been executed, it repeats, but fruit becomes the second element of the fruits vector. We do not actually need to call this variable fruit. We can call it whatever we want!\n\n\nCode\nfor(dog in fruits){\n  print(dog)\n}\n\n\n[1] \"apple\"\n[1] \"banana\"\n[1] \"orange\"\n[1] \"mango\"\n\n\nIt is useful to give this iterator a useful name, though calling it dog in this instance would be bad practice, as it does not describe itself!\nA more complex example that checks if each integer between one to twenty is divisible by three can be formulated by nesting an if statement inside the for loop. Here, nesting is a fancy way of saying that the if statement is within the for loop.\n\n\nCode\nfor(i in 1:20){   # Loop over integers from 1 to 20\n  if(i %% 3 == 0){ # This checks if a number is divisible by 3\n    print(i)       # Prints the number if the condition is true\n  }\n}\n\n\n[1] 3\n[1] 6\n[1] 9\n[1] 12\n[1] 15\n[1] 18\n\n\nNotice that we do this in a vectorised way without the need for loops.\n\n\nCode\n1:20 %% 3 == 0\n\n\n [1] FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE\n[13] FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE\n\n\nTypically, vectorised statements in R are faster than equivalent code using loops, so when possible, it’s a good idea to vectorise!\nWe can also nest a for loop inside a for loop.\n\n\nCode\nfor(i in 10:20){\n  for(j in 3:5){\n    if(i %% j == 0)\n      print(paste(i, \"mod \", j, \"= 0\"))\n  }\n}\n\n\n[1] \"10 mod  5 = 0\"\n[1] \"12 mod  3 = 0\"\n[1] \"12 mod  4 = 0\"\n[1] \"15 mod  3 = 0\"\n[1] \"15 mod  5 = 0\"\n[1] \"16 mod  4 = 0\"\n[1] \"18 mod  3 = 0\"\n[1] \"20 mod  4 = 0\"\n[1] \"20 mod  5 = 0\"\n\n\nIn this example, we used the paste() function to create a string by pasting together its inputs."
  },
  {
    "objectID": "Lesson_1.html#functions",
    "href": "Lesson_1.html#functions",
    "title": "3  An Introduction to R Programming",
    "section": "3.6 Functions",
    "text": "3.6 Functions\nSometimes we want to execute code multiple times but under different conditions. We can use a function to transform an input to an output using a consistent method or recipe. We actually just saw a function, paste. This function takes string inputs and glues them together into a single string. We can create our own functions too! For example, may want to create a chatbot that can respond differently based on its inputs.\nLet’s build an (extremely) basic chatbot.\nFirst, let’s just get the chatbot to repeat what we told it.\n\n\nCode\nchatbot <- function(input){\n  output <- paste(\"You said, '\", input, \"'.\", sep = \"\")\n  return(output)\n}\n\n\nWe make use of the paste function to have the chatbot say “You said” and then repeat what we said. The function takes an input that we have called input (you can call it something else too) and returns (or outputs) the output variable that we made. The function is saved in the variable chatbot.\nTo use the function, we pass an input inside curly braces ().\n\n\nCode\nchatbot(\"Hello\")\n\n\n[1] \"You said, 'Hello'.\"\n\n\nCode\nchatbot(\"Goodbye\")\n\n\n[1] \"You said, 'Goodbye'.\"\n\n\nNote that we defined the function using informative names. We could have defined the function like this:\n\n\nCode\ni <- function(j){\n  k <- paste(\"You said, '\", j, \"'.\", sep = \"\")\n  return(k)\n}\ni(\"Hello\")\n\n\n[1] \"You said, 'Hello'.\"\n\n\nBut it’s hard for someone reading our code (usually ourselves, six months later, confused to no end) to work out what it does.\nLet’s build a slightly more complicated (but still very basic) chatbot using a switch statement. A switch statement will look for the first match. As an exercise, try and see if you can understand the switch statement based on a few of the outputs of our amazing chatbot below.\n\n\nCode\namazing_chatbot <- function(input) {\n  response <- switch(input,\n                     \"hi\" = \"Hello!\", # If input is \"hi\" the response will be \"Hello!\"\n                     \"how are you?\" = \"I'm doing well, thank you. How about you?\",\n                     \"what's your name?\" = \"My name is Chatbot. Nice to meet you!\",\n                     \"what time is it?\" = paste(\"It's\", format(Sys.time(), \"%H:%M\"), \"right now.\"),\n                     \"what is R?\" = \"R is a programming language used for statistical computing and graphics.\",\n                     \"what can you do?\" = \"I can answer your questions or just chat with you.\",\n                     \"bye\" = \"Goodbye!\",\n                     \"see you later\" = \"See you later!\",\n                     \"thanks\" = \"You're welcome!\",\n                     \"thank you\" = \"You're welcome!\",\n                     \"I don't understand :(\" # Default response\n                     )\n  return(response)\n}\n\n# Example usage\namazing_chatbot(\"hi\")\n\n\n[1] \"Hello!\"\n\n\nCode\namazing_chatbot(\"what time is it?\")\n\n\n[1] \"It's 15:51 right now.\"\n\n\nCode\namazing_chatbot(\"You're smart\")\n\n\n[1] \"I don't understand :(\""
  },
  {
    "objectID": "Lesson_1.html#exercises",
    "href": "Lesson_1.html#exercises",
    "title": "3  An Introduction to R Programming",
    "section": "3.7 Exercises",
    "text": "3.7 Exercises\n\n3.7.1 Exercise 1\n\nCreate function that returns the sea level \\(s(t)\\) at time \\(t\\) defined as \\[\ns(t) = \\cos\\left(\\frac{2 \\pi t}{24}\\right)\n\\] where \\(t\\) is in 24 hour time.\n\nHint: cos() is a R function, and pi is \\(\\pi\\).\n\nUsing your function, calculate the sea level at 12 noon.\nUsing a for loop, and your function, calculate the sea level every hour from midnight to midnight.\n\nHint: What is the vector we should iterate over? What needs to go into the function method?\n\nLet’s build on that loop. When the sea level rises above 0.8, let everyone know that the water will be deep!\n\nHint: How can you check if something will be true or not? After, try using a print-and-paste statement to say what the depth is and what the time is.\n\nIt turns out that the people at the beach don’t know 24-hour time. We need to convert the time into AM/PM time for them.\n\nHint: We might need to check if it’s before midday or after midday to work out if we use AM or PM and whether or not we should subtract 12. Try using the paste function again!\n\n\n3.7.2 Solution\n\n\nCode\nget_sealevel <- function(time){\n  output <- cos(2*pi*time/24)\n  return(output)\n}\n\nget_sealevel(12)\n\n\n[1] -1\n\n\nCode\nfor(time in 0:24){\n  # Get the sea level for the current time\n  sealevel <- get_sealevel(time)\n  # Uncomment for part 3\n  #print(sealevel)\n  \n  # Format the time in 12h time\n  if(time > 12){\n    # Afternoon\n    time_12h = paste(time-12, \"PM\")\n  }else{\n    # Morning\n      time_12h = paste(time,\"AM\")\n    }\n  \n  # If the sea level is high!\n  if(sealevel > 0.8){\n    alert <- paste(\"The time is\", time_12h, \"and the sea level is getting deep: \", round(sealevel,3))\n  }else{ # If its low!\n    alert <- paste(time_12h, \"is a nice time to swim! The sea level is only\", round(sealevel,3))\n  }\n  print(alert)\n}\n\n\n[1] \"The time is 0 AM and the sea level is getting deep:  1\"\n[1] \"The time is 1 AM and the sea level is getting deep:  0.966\"\n[1] \"The time is 2 AM and the sea level is getting deep:  0.866\"\n[1] \"3 AM is a nice time to swim! The sea level is only 0.707\"\n[1] \"4 AM is a nice time to swim! The sea level is only 0.5\"\n[1] \"5 AM is a nice time to swim! The sea level is only 0.259\"\n[1] \"6 AM is a nice time to swim! The sea level is only 0\"\n[1] \"7 AM is a nice time to swim! The sea level is only -0.259\"\n[1] \"8 AM is a nice time to swim! The sea level is only -0.5\"\n[1] \"9 AM is a nice time to swim! The sea level is only -0.707\"\n[1] \"10 AM is a nice time to swim! The sea level is only -0.866\"\n[1] \"11 AM is a nice time to swim! The sea level is only -0.966\"\n[1] \"12 AM is a nice time to swim! The sea level is only -1\"\n[1] \"1 PM is a nice time to swim! The sea level is only -0.966\"\n[1] \"2 PM is a nice time to swim! The sea level is only -0.866\"\n[1] \"3 PM is a nice time to swim! The sea level is only -0.707\"\n[1] \"4 PM is a nice time to swim! The sea level is only -0.5\"\n[1] \"5 PM is a nice time to swim! The sea level is only -0.259\"\n[1] \"6 PM is a nice time to swim! The sea level is only 0\"\n[1] \"7 PM is a nice time to swim! The sea level is only 0.259\"\n[1] \"8 PM is a nice time to swim! The sea level is only 0.5\"\n[1] \"9 PM is a nice time to swim! The sea level is only 0.707\"\n[1] \"The time is 10 PM and the sea level is getting deep:  0.866\"\n[1] \"The time is 11 PM and the sea level is getting deep:  0.966\"\n[1] \"The time is 12 PM and the sea level is getting deep:  1\""
  },
  {
    "objectID": "Lesson_2.html#motivation-and-definition",
    "href": "Lesson_2.html#motivation-and-definition",
    "title": "4  Basic Algorithms",
    "section": "4.1 Motivation and Definition",
    "text": "4.1 Motivation and Definition\nWhen we want to solve a problem, especially one of a mathematical nature, we often need to follow a specific set of operations to achieve the desired result.\nWe call these sets of operations algorithms. In computer science and mathematics, we encode operations using our programming language so that the computer can do all the hard work for us!\nThe outcome of this lesson is not just to be able to understand a few algorithms but to understand the thought process behind how the algorithms you will come across were created."
  },
  {
    "objectID": "Lesson_2.html#length",
    "href": "Lesson_2.html#length",
    "title": "4  Basic Algorithms",
    "section": "4.2 Length",
    "text": "4.2 Length\nThe first algorithm we will learn will allow us to find the length of a vector input.\nTake the vector below:\n\n\nCode\nx <- c(1,1,2,3,5,8)\nx\n\n\n[1] 1 1 2 3 5 8\n\n\nWe can count the number of elements to find the length of the vector. Here, we have six elements, so the length of x is six.\nHow did we work that out though?\nProbably, you started counting the elements from left to right (or maybe right to left!). Starting with one, you progressively increment the running count by one each time you move to the next element.\nWhen writing an algorithm, we must carefully consider the procedure that we need to follow to achieve the desired result. Usually, we can start with a basic example and then try to abstract our thought process to arrive at something general.\nWe might develop some pseudo code (human-readable code) as a starting point for the length algorithm.\n\n\nCode\ninitialise running total as 0.\nstart with first (left-most) element\nincrement running total by 1.\nmove to next element (to the right) and repeat\nreturn running total\n\n\nIn the above pseudo-code, we have started to abstract and proceduralised a process that we might use to find the length of a vector.\nNow let’s try and write that out in R.\n\n\n\n\n\n\nNote\n\n\n\nBecause an algorithm will likely be used multiple times, we don’t want to write it out each time we need it! Instead, we can put the algorithm inside a function, so that whenever we need to apply an algorithm to an input, we can just call the function.\n\n\n\n4.2.1 Basic Length Algorithm\n\n\nCode\nbasic_length <- function(x){\n  # Initialise the running total as zero\n  running_total <- 0\n  \n  # Loop over all elements of the input x\n  for(element in x){\n    \n    # Increment the previous running total by 1\n    running_total <- running_total + 1\n  }\n  \n  # Return running total\n  # Once all elements have been looped over\n  return(running_total)\n}\n\n\n\n\n4.2.2 Testing\nNow that we have created a function to find the length of an input vector let’s try it out!\n\n\nCode\nbasic_length(x)\n\n\n[1] 6\n\n\nCode\nbasic_length(1:1000)\n\n\n[1] 1000\n\n\nCode\nbasic_length(c(\"cat\", \"dog\", \"frog\"))\n\n\n[1] 3\n\n\n\n\n4.2.3 A Note on R\nR is not a particularly fast programming language. Running a for loop in R takes considerably longer than running an equivalent loop in Python and much longer than running in a language like C. However, R is still incredibly useful, so this should not immediately deter us from using R.\nR was built with statisticians in mind, is open source, and has a fantastic package management system that allows R users to share code through the community easily.\nThere are many packages that can be imported, allowing you to use a function that someone else may have created (we will come across this in a future lesson). People might often use a faster language, like C, under the hood to speed up their packaged functions. As well as this, there are many base functions (functions that exist in the base environment, i.e., without any packages imported) that exist and are fast. Usually, they are either coded smartly or implemented in C. For example, the function length already exists in the base environment, so we never really needed to code it. We can pit our function basic_legnth against the base environment function length to see who finishes first!\n\n\nCode\nsystem.time(basic_length(1:1e7))\n\n\n   user  system elapsed \n   0.13    0.00    0.13 \n\n\nCode\nsystem.time(length(1:1e7))\n\n\n   user  system elapsed \n      0       0       0 \n\n\nUh-oh! Our function took 0.14s, but the base environment took 0.00s (rounded to 2 decimal places). Our function is SLOW :(. I’m not exactly sure how the length function was implemented in R, but they likely did something smart, like check how big the memory block was for the object 1:1e7. This is like turning a book to its last page and reading the page number. So while our loop would have run the line running_total <- running_total + 1 10000000 times, their code probably just did one simple operation. This touches on a concept called computational complexity, but we can shelve that for another day and see a few more basic algorithms first."
  },
  {
    "objectID": "Lesson_2.html#sum",
    "href": "Lesson_2.html#sum",
    "title": "4  Basic Algorithms",
    "section": "4.3 Sum",
    "text": "4.3 Sum\nIn mathematical notation, if we have an \\(n-\\)dimesional vector \\(\\textbf{x} = \\left(x_1, \\cdots, x_n\\right)\\), the sum of the elements of \\(\\textbf{x}\\) is\n\\[\\begin{equation}\n\\label{sum}\n\\text{Sum}(\\textbf{x}) = \\sum_{i = 1}^n x_i .\n\\end{equation}\\]\nAs an exercise, write a function basic_sum that takes a vector input and returns the sum of the elements in the vector.\nTo start, think about the procedure that you might follow when calculating the sum of a vector, and come up with some pseudo code that generalises this procedure. Then try to implement that procedure in R.\n\n4.3.1 Basic Sum\nWhen you have tried, reveal a potential solution below by clicking the dropdown arrow. Remember, there is not just one way to find the sum!\n\n\nCode\nbasic_sum <- function(x){\n  n <- length(x)\n  sum <- 0\n  for(i in 1:n){\n    sum <- sum + x[i]\n  }\n  return(sum)\n}\n\n\n\n\nCode\nbasic_sum(1:10)\n\n\n[1] 55\n\n\nCode\nbasic_sum(c(-1,-4,2))\n\n\n[1] -3\n\n\nAs we can see, the function basic_sum correctly finds the sum for the given input vectors above.\n\n\n4.3.2 Explanation\nWhen you take the sum of elements of a vector, say\n\n\nCode\nx <- c(1,4,5,9)\nx\n\n\n[1] 1 4 5 9\n\n\nYou may progressively compute the cumulative sums: \\(1+4 =5\\), then \\(5 +5 = 10\\), and finally \\(10 + 9 = 19\\).\nWe may generalise this behaviour to\n\n\nCode\nfind the number of elements to sum over\nstart at the first element\nfind the cumulative sum\ngo to the next element, find the cumulative sum, and repeat\nreturn the cumulative sum at the end\n\n\nWhen we express the sum mathematically, as we did in equation\\(\\ref{sum}\\), we can see that the summation takes place from \\(i=1\\) to \\(i=n\\), where \\(n\\) was the length of the vector \\(\\textbf{x}\\). In the function basic_sum, we find \\(n\\) using the length function to define the indices we need to loop over.\nWe then successfully loop through the input vector and find the cumulative sum. Finally, we return the sum.\n\n\n4.3.3 Alternative Basic Sum\nNote that while we could loop over the indices 1:n of the input vector x and find the element at index i as x[i], we can just loop over the elements of the vector themselves.\n\n\nCode\nalternative_basic_sum <- function(x){\n  sum <- 0\n  for(x_i in x){\n    sum <- sum + x_i\n  }\n  return(sum)\n}\n\n\nLet’s compare how long these functions take to run and compare it to the base function sum.\n\n\nCode\nsystem.time(basic_sum(1:1e7))\n\n\n   user  system elapsed \n   0.19    0.00    0.19 \n\n\nCode\nsystem.time(alternative_basic_sum(1:1e7))\n\n\n   user  system elapsed \n   0.14    0.00    0.14 \n\n\nCode\nsystem.time(sum(1:1e7))\n\n\n   user  system elapsed \n      0       0       0 \n\n\nWe can see that the first function, basic_sum, took the longest. The second function, alternative_basic_sum, was completed in about half the time. It is faster because fewer operations need to occur than the function basic_sum. Instead of finding the length of the vector, finding the indices, and indexing the vector by the indices, we simply loop over the elements. There are fewer steps for the computer to take, and hence, executes faster.\nOf course, the base function sum completely demolishes our feeble attempt at writing the summation function. Fear not; our attempts are not futile. This is our first introduction to algorithms; we should not expect to challenge grand wizards without experience and emerge victorious."
  },
  {
    "objectID": "Lesson_2.html#min",
    "href": "Lesson_2.html#min",
    "title": "4  Basic Algorithms",
    "section": "4.4 Min",
    "text": "4.4 Min\nThe next basic function that we will look at is the min function, which returns the minimum element of a vector. For example, the base R function performs as follows:\n\n\nCode\nx <- c(3,pi,log(100))\nmin(x)\n\n\n[1] 3\n\n\nTry to find the minimum of a vector using an example. Then generalise and proceduralise the method that you used.\n\n4.4.1 Basic Min Function\nReveal the code below once you have tried this for yourself:\n\n\nCode\nbasic_min <- function(x){\n  min <- Inf\n  for(x_in in x){\n    if(x_i < min){\n      min <- x_i\n    }\n  }\n  return(min)\n}\n\n\n\n4.4.1.1 Explanation\nIn the function basic_min, we follow a similar procedure to the basic_sum algorithm, but instead of finding the cumulative sum, we find the running minimum, i.e., progressively find the minimum of the first few elements until we have looked through all elements. This is done by using an if statement, where we check to see if the current element is less than the minimum of the preceding elements. We initialise the minimum as Inf, (R’s representation of \\infty). We could also initialise the minimum as x[1].\n\n\n\n4.4.2 Bonus Exercise\nWhat if we wanted the index of the minimum element, not the minimum element? For example, the index, or position of the minimum element in the vector \\(\\textbf{x} = \\left(3, \\pi, \\log(100)\\right)\\) is \\(1\\), as the minimum element is \\(3\\), and \\(x_1 = 3\\). If you haven’t come across this before, we call this \\[\\underset{i}{\\arg \\min} (x_i),\\] as this is the argument (here the index \\(i\\) is the argument), that minimises \\(x_i\\)."
  },
  {
    "objectID": "Lesson_2.html#exercises",
    "href": "Lesson_2.html#exercises",
    "title": "4  Basic Algorithms",
    "section": "4.5 Exercises",
    "text": "4.5 Exercises\nThe remaining functions are left as exercises for you to complete.\n\n4.5.1 Mean\nFind the mean of an input vector in a function basic_mean. Compare your function to the base R function mean.\nRecall the mean \\(\\bar{\\mathbf{x}}\\) of \\(n-\\)dimensional vector \\(\\mathbf{x}\\) is defined as\n\\[\n\\bar{\\mathbf{x}}= \\dfrac{\\sum_{i=1}^n x_i}{n}.\n\\]\n\n\n4.5.2 Solution\nUnfold the solution when you are ready.\n\n\nCode\nbasic_mean <- function(x){\n  mean <- basic_sum(x)/length(x)\n  return(mean)\n}\n\n\n\n\n4.5.3 Standard Deviation\nThe standard deviation \\(\\sigma\\) of a sample is defined as\n\\[\n\\sigma(\\mathbf{x}) = \\sqrt{\\frac{\\sum_{i=1}^n(\\bar{x} -x_i)^2}{n-1}},\n\\] where \\(\\mathbf{x}\\) is an \\(n-\\)dimensional vector with mean \\(\\bar{\\mathbf{x}}\\).\nWrite a function basic_sd to find the standard deviation of an input vector. You may use your function basic_mean to help. Compare how long your solution takes to run compared to the base function sd.\n\n4.5.3.1 Solution\nUnfold the solution when you are ready.\n\n\nCode\nbasic_sd <- function(x){\n  n <- length(x)\n  mean <- basic_mean(x)\n  # Sum of the squared differences (errors)\n  sse <- 0\n  for(x_i in x){\n    sse <- sse + (mean-x_i)^2\n  }\n  sd <- sqrt(sse/(n-1))\n  return(sd)\n}\n\n\n\n\n\n4.5.4 Mode (Harder)\nThe mode of a vector is the value that appears most frequently). For example, the mode of the vector \\[ x = (1,2,2,4)\\] is \\(2\\) since this occurs the most frequently.\nWrite a function basic_mode that finds the mode of a vector.\n\nAssume that the vector is unimodal, i.e. there is only one mode. The vector \\[ x = (1,1,2,2) \\] is not unimodal, since there is no single most frequently occurring value. We call this type of vector bimodal.\n\n\n4.5.4.1 Solution\nA very basic (and inefficient implementation of basic_mode is given below)\n\n\nCode\nbasic_mode <- function(x){\n  \n  # Function to find how many times \n  # an element x_i appears in the vector x\n  times_appears <- function(x_i,x){\n    count <- 0\n    for(x_i_prime in x){\n      if(x_i_prime == x_i){\n        count <- count + 1\n      }\n    }\n    return(count)\n  }\n  \n  # Set up a variable to find how many times the \n  # mode appears (initialised at zero)\n  max_count <- 0\n  # Progressively find the mode as \n  # the variable that appears more\n  # than max_count \n  for(x_i in x){\n    x_i_count <- times_appears(x_i,x)\n    if(x_i_count > max_count){\n      max_count <- x_i_count\n      mode <- x_i\n    }\n  }\n  return(mode)\n}"
  }
]